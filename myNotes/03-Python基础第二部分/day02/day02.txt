day01回顾:
元组 tuple
  字面值表示方式
    1,2,3
    (1,2,3)
    (1,)
    1,
  tuple()
  tuple(可迭代对象)
元组的运算:
  + +=  * *= 
  < > <= >= != 
  in / not in 
  []  索引和切片
    元组不支持索引和切片赋值

字典 dict
  键(key)   -   值(value)
 (不可变类型)   （任意类型）

字典的字面值
  {}
  {1: "一", 2:'二'}
  构造(创建)函数 dict
    dict()
    dict(可迭代对象)
    dict(**kwargs)
        dict(a=1, b=2)

  访问字典:
    d = {1: "一", 2:'二'}
    v = d[1]
  修改/添加数据
    d[3] = '三'
  删除 del 语句
    del d[1]

  字典的方法:
    d.get(v, default)
    d.update(d2)
    d.keys()
    d.values()
    d.items()

字典推导式:
   { 键表达式 : 值表达式 for 变量 in 可迭代对象 if ... }

字典 vs 列表
  1. 都是可变的容器
  2. 索引方式不同(列表用整数索引，字典用键索引)
  3. 字典的查找速度可能快于列表(重要)
  4. 列表的存储是有序的，字典的存储是无序的


day02笔记:
集合 set
  集合是可变的容器
  集合内的数据对象是唯一的（不能重复多次的)
  集合是无序的存储结构，集合中的数据没有先后关系
  集合内的元素必须是不可变对象
  集合是可迭代的
  集合是相当于只有键没有值的字典(键则是集合的数据)

创建空的集合
   s = set()  # set() 创建一个空的集合

创建非空集合
   s = {1, 2, 3}  # 集合中的三个整数1,2,3

集合的构造函数 set
  set() 创建空集合
  set(iterable)  用可迭代对象创建一个新的集合对象

示例:
  s = set("ABC")
  s = set('ABCCBA')
  s = set({1:"一", 2:'二', 5:'五'})
  s = set([1, 3.14, False])
  s = set((2,3,5,7))
  # s = set([1, 2, [3.1, 3.2], 4])  # 错的[3.1, 3.2]是可变对象

集合的运算:
  交集，并集，补集，子集，超集

& 生成两个集合的交集
  s1 = {1,2,3}
  s2 = {2,3,4}
  s3 = s1 & s2  # s3 = {2, 3}

| 生成两个集合的并集
  s1 = {1,2,3}
  s2 = {2,3,4}
  s3 = s1 | s2  # s3 = {1,2,3,4}

-  生成两个集合的补集
  s1 = {1,2,3}
  s2 = {2,3,4}
  # 生成属于s1,但不属于s2的所有元素的集合
  s3 = s1 - s2

^ 生成两个集合的对称补集
  s1 = {1,2,3}
  s2 = {2,3,4}
  s3 = s1 ^ s2  # s3 = {1, 4}
  # 等同于 s3 = (s1 - s2) | (s2 -s1)

< 判断一个集合是另一个集合的子集
> 判断一个集合是另一个集合的超集
  s1 = {1, 2, 3}
  s2 = {2, 3}
  s2 < s1  # True  判断子集
  s1 > s2  # True  判断超集

==  != 集合相同/不同
  s1 = {1, 2, 3}
  s2 = {2, 3, 1}
  s1 == s2  # True
  s1 != s2  # False  # 集合的数据没有先后关系

in / not in 运算符
  等同于字典，in 运算符用于集合中，当某个值存在于集合中，则为真，否则为假
  not in 与 in 返回值相反
  示例:
    s = {1, 'Two', 3.14}
    1 in s  # True
    2 in s  # False
    3.14 not in s  # False
    4 not in s   # True

python3中可用于集合的函数:
  len(x) max(x), min(x), sum(x), any(x), all(x)

集合是可迭代对象
  s = {1, 2, 3}
  for x in s:
     print(x)

练习:
  经理有: 曹操， 刘备， 周瑜
  技术员有: 曹操， 周瑜， 张飞，赵云
  用集合求:
    1. 即是经理也是技术员的有谁?
    2. 是经理，但不是技术员的有谁?
    3. 是技术员，不是经理的都有谁?
    4. 张飞是经理吗？
    5. 身兼一职的人有谁?
    6. 经理和技术员共有几个人?


思考:
  集合是可变对象，有方法能添加，删除集合的数据吗？

集合的方法:
  见 : python_base_docs_html/set.html

对于不可变对象,  有时赋合赋值运算符不同于 运算后再赋值
  如:
    s1 = s1 | s2
    不等同于
    s1 |= s2
  见 : 01_set.py

练习:
  任意输入一个单词，存入集合中，当输入空字符串时结束输入，
    1) 打印您输入的单词的种类数(去重)
    2) 每个单词都打印到终端上显示
      思考:
        如何让打印的次序和输入的次序一致?



集合推导式
  用可迭代对象来创建(生成)集合的表达式

  语法:
    {表达式 for 变量 in 可迭代对象 [if 真值表达式]}
    [] 括号部分内容代表可省略

  示例:
    L = [2, 3, 5, 7, 3, 5, 7, 11]
    s = {x**2 for x in L}  # s={4,9,25,49,121}

集合推导式的嵌套规则与列表推导式相同

练习:
  1. 模拟一个点名系统，已知全班学生名单，随机打印学生的姓名进行点名，并得到此学生是否已到信息，输入'y'代表已到，其它输入代表未到场
    点名结束后打印未到者名单



问题:
  能用集合作为字典的键吗?

固定集合 frozenset
  固定集合是不可变的，无序的，含有唯一元素的集合

作用：
  固定集合可以作为字典的键，也可以作为集合的值（元素)

创建空的固定集合
   fs = frozenset()
创建非空的固定集合
   fs = frozenset([2,3,5,7])

构造函数:
  frozenset()
  frozenset(可迭代对象) # 同set函数一致,返回固定集合

固定集合的运算:
  & 交集
  | 并集
  - 补集
  ^ 对称补集
  > >= < <= == !=
  in / not in 
  (以上运算规则等同于set中的用法)
固定集合的方法:
  相当于集合的全部方法去掉修改集合的方法



阶段总结

数据类型
  不可变数据类型
    bool, int, float, complex, str, tuple,
    frozenset, bytes(以后再讲)
  可变数据类型:
    list, dict, set, bytearray(字节数组，后面再讲)

值:
  None, True, False ....

运算符:
  + - * / // % **
  > >= < <= == !=
  is   is not
  in   not in
  not   and    or
  &  |  ^
  +(正号) -(负号)

表达式
  1
  1 + 2
  len([1,2,3]) 
  条件表达式 x if x > y else y
  全部的推导式:
     列表，字典，集合推导式(三种)

语句:
  表达式语句:
    print("abc")
    'hello'
  赋值语句
    a = 100
    a = b = c = 200
    x, y = 100, 200
  if 语句
  while 语句
  for 语句
  break 语句
  continue 语句
  pass 语句
  del 语句
内建函数:
  len(x)
  max(x)
  min(x)
  sum(x)
  any(x)
  all(x)
  ------------
  bool(x)
  int(x)
  float(x)
  complex(x)
  str(x)
  list(x)
  tuple(x)
  dict(x)
  set(x)
  frozenset(x)
--------------
  abs(x)
  round(x)
  pow(x, y,...)
----------------
  bin(x)
  oct(x)
  hex(x)
  chr(x)
  ord(x)
---------------
  range([start, ]stop[, step])
---------------
  input(x)
  print(...)

函数 function
  什么是函数:
    函数是可以重复执行的语句块,可以重复使用
  作用：
    1. 用于封装语句块，提高代码的重用性
    2. 定义用户级别的函数

函数定义(创建)语句 def 语句的语法:
    def 函数名(形参列表):
        语句块

说明:
  1. 函数的名字就是语句块的名称
  2. 函数名的命名规则与变量名相同(函数名必须为标识符)
  3. 函数有自己的名字空间，在函数外部不可以访问函数内部的变量，在函数内部可以访问函数外部的变量,通常让函数处理外部数据需要用参数给函数传入一些数据
  4. 函数的参数列表可以为空
  5. 语句部分不能为空。如果为空需要填充pass语句

示例见:
  code/02_def.py

函数的调用
  函数名(实际调用传递参数列表)
    注: 实际调用传递参数以后称为实参

  说明:
    函数调用是一个表达式
    如果没有return语句，此函数执行完毕后返回None 对象
    如果函数需要返回其它的对象需要用到return语句
  示例见:
    02_def.py
    03_def2.py



练习 ：
  1. 写一个函数myfun, 此函数用显示两个参数的相关信息
     函数:
       def myfun(a, b):
           此处自己实现
    此函数给定两个参数，打印关于两个参数的信息:
        1) 打印两个参数的最大值
        2) 打印两个参数的和
        3) 打印两个参数的积(相乘)
        4) 打印从a开始到b结束的所有偶数:
    如:
      myfun(3, 10)
    打印如下:
      最大值是: 10
      和是: 13
      积是: 30
      3到10之间的偶数是: 4 6 8 
    myfun(10, 20)
    打印...

  2 猴子吃桃
    有一只小猴子，摘了很多桃
      第1天吃了全部桃子的一半，感觉不饱又吃了一个
      第2天吃了剩下的一半，感觉不饱又吃了一个
      ... 以此类推
      到第10天，发现只剩一个了
    请问第一天摘了多少桃?

  3. 完全数:
    1 + 2 + 3 = 6 (6为完全数)
    1, 2, 3 都为 6的因数(能被一个数x整数的数为y,则y为x的因数)
    1 x 6 = 6
    2 x 3 = 6
    完全数是指除自身以外，所有的因数相加之和等于自身的数
    求 4 ~ 5个完全数并打印
    答案:
      6
      28
      496
      ....






