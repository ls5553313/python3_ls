day01回顾
面向对象编程
  物体(对象)
    属性: 记录对象所拥有的数据
      实例变量
    行为: 描述一个对象能做什么
      实例方法  (self, ...)

类 class
  # 创建一个类
  class 类名(继承列表):
       类的语句块

  # 创建一个函数
  def 函数名(参数列表):
       语句块

实例方法 method
  def 实例方法名(self, 形参1, 形参2, ...)

  # 调用语句
    对象.实例方法名(实参1, 实参2)

属性:
  对象.属性名 = 表达式
  v = 对象.属性名

实始化方法
  def __init__(self, ....):
      语句块

析构方法:
  def __del__(self):
      语句块

构造函数:
   类名(实参列表)
   作用:创建此类型的对象

实例的预置属性:
   __dict__
     用来绑定对象的属性的字典
   __class__
     用来绑定创建自己的类

用来判断类的函数
  isinstance(obj, 类名或类名的元组) 
  type(obj)  # 返回对象的类

day02笔记:

类变量 class variable(也叫类属性)
  类变量是类的属性,此属性属于类

  作用:
    用来记录类相关的数据

  说明:
    类变量可以通过类直接访问
    类变量可以通过类的实例直接访问
    类变量可以通过此类的实例的__class__属性间接访问
  示例:
    class Human:
        count = 0  # 创建类变量
    详见:
      01_class_variable.py 
      02_class_variable.py 
  类变量的应用案例:
     - 用类变量来记录对象的个数
     见:
       03_car_count.py
类的文档字符串:
  类内第一个没有赋值给任何变量的字符串是类的文档字符串

  说明:
    类的文档字符串用类的__doc__属性可以访问
    类的文档字符串可以用help()函数查看
  示例:
    classdoc.py



类的__slots__列表
  作用:
    限定一个类的实例只能有固定的属性(实例变量)
    通常为防止错写属性名而发生运行时错误

  示例:
    04_slots.py

  说明:
    含有__slots__列表的类创建的实例对象没有__dict__属性,即此实例不用字典来保存对象的属性(实例变量)
  
问题:
  1. 对象内可以有:
     实例变量
     实例方法
  2. 类内可以有:
     类变量
     类方法 # 这个可以有

类方法 @classmethod
  类方法是描述类的行为的方法,类方法属于类

  说明:
    1. 类方法需要用@classmethod装饰器定义
    2. 类方法至少有一个形参,第一个形参用于绑定类,约定写为'cls'
    3. 类和该类的实例都可以调用类方法
    4. 类方法不能访问此类创建的实例的属性(只能访问类变量)

  示例见:
    05_classmethod.py
    06_classmethod.py


问题:
  1. 类方法属于类
  2. 实例方法属于该类的实例
  3. 请问: 类内能不能有函数,这个函数不属于类,也不属于实例

静态方法 @staticmethod
  静态方法不属于类,也不属于类的实例,它相当于定义在类内普通函数,只是它的作用域属于类

  示例见:
    07_staticmethod.py


练习
  1. 用类来描述一个学生的信息(可以修改之前的写的Student类)
    class Student:
          # 此处自己实现
    
    要求该类的对象用于存储学生信息:
         姓名,年龄,成绩
    将这些对象存于列表中.可以任意添加和删除学生信息
       1. 打印出学生的个数
       2. 打印出所有学生的平均成绩
    (建议用类变量存储学生的个数,也可以把列表当作类变量)

  答案见:
    exercise/student.py




继承 inheritance 和 派生 derived
什么是继承/派生
  1. 继承是指从已有的类中衍生出新类,新类具有原类的行为,并能扩展新的行为
  2. 派生就是从一个已有类中衍生(创建)新类,在新类上可以添加新的属性和行为

继承和派生的目的:
  继承是延续旧类的功能
  派生是为了在旧类的基础上添加新的功能

作用:
  1.用继承派生机制,可以将一些共有功能加在基类中,实现代码的共享
  2. 在不改变基类的基础上改变原有功能


继承/派生的名词
  基类(base class), 超类(super class), 父类(father class)
  派生类(derived class) / 子类(child class)

单继承
  语法:
    class 类名(基类名):
        语句块
  说明
    单继承是指派生类由一个基类衍生出来的类

示例见:
  08_inherit.py





继承说明:
  任何类都直接或间接的继承自object类
  object类是一切类的超类(祖类)

类的__base__ 属性
  __base__属性用来记录此类的基类


覆盖 override
  什么覆盖
    覆盖是指在有继承关系的类中,子类中实现了与基类同名的方法,在子类实例调用该方法时,实例调用的是子类中的覆盖版本的方法,这种现象叫做覆盖

  示例见:
    10_override.py


问题:
  当覆盖发生时,子类对象能否访问父类中的方法?

子类对象显式调用基类方法的方式:
  基类名.方法名(实例, 实际调用传参)

super函数
  super(type, obj) 返回绑定超类的实例
  super()  返回绑定超类的实例,等同于:
           super(__class__, 实例方法的第一个参数)
           (必须在方法内调用)
示例:
  12_super.py

显式调用基类的初始化方法：
  当子类中实现了__init__方法时，基类的__init__方法并不会被自动调用，此时需要显式调用

示例见:
  13_super.py

预告
　　封装
  多态
  多继承
  运算符重
  with语句




1. 看懂学生管理系统的类的封装的代码

2. 写一个类Bicycle(自行车)类,有run方法,调用时显示骑行里程km
  class Bicycle:
      def run(self, km):
          print("自行车骑行了", km, "公里")

  再写一个类EBicycle(电动自行车)类,在Bicycle类的基础上添加电池电量volume属性,有两个方法:
     1. file_charge(self, vol) 用来充电,vol为电量
     2. run(km) 方法每骑行10km消耗电量1度, 同时显示当前电量,当电量耗尽时,则调用Bicycle的run方法骑行
    class EBicycle(Bicycle):
         ...
  b = Bicycle()
  b.run(10)  # 自行车骑行了 10 公里
  e = EBicycle(5)
  e.run(10)  # 电动骑行了 10 公里
  e.run(100) # 电动骑行了 40 公里, 自行车骑行了 60 公里
  b.fill_charge(10)
  b.run(100)